"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var mapRange = function mapRange(range) {
  if (!range) return {};
  var newTokens = {};

  var _range = _slicedToArray(range, 2),
      start = _range[0],
      end = _range[1];

  for (var i = start; i <= end; i++) {
    newTokens[i] = null;
  }
  return newTokens;
};
var mapLines = function mapLines(lines) {
  var newTokens = {};
  lines.forEach(function (line) {
    return newTokens[line] = null;
  });
  return newTokens;
};

var getTokensPerLineFromObject = function getTokensPerLineFromObject(_ref) {
  var _ref$lines = _ref.lines,
      lines = _ref$lines === undefined ? [] : _ref$lines,
      range = _ref.range,
      _ref$ranges = _ref.ranges,
      ranges = _ref$ranges === undefined ? [] : _ref$ranges,
      tokens = _ref.tokens;

  var newTokens = {};

  Object.assign(newTokens, mapLines(lines));
  Object.assign(newTokens, mapRange(range));
  Object.assign.apply(Object, [newTokens].concat(_toConsumableArray(ranges.map(mapRange))));
  Object.assign(newTokens, tokens);

  return newTokens;
};

var expandString = function expandString(part) {
  // Transforms something like
  // - "1:3" to [1,2,3]
  var _part$split = part.split(":"),
      _part$split2 = _slicedToArray(_part$split, 2),
      start = _part$split2[0],
      end = _part$split2[1];

  if (!end) {
    return [+start];
  }
  var list = [];
  for (var i = +start; i <= +end; i++) {
    list.push(i);
  }
  return list;
};

var getTokensPerLineFromString = function getTokensPerLineFromString(step) {
  if (step.trim() === "*") {
    return { all: true };
  }

  var parts = step.split(/,(?![^\[]*\])/g).map(function (part) {
    var tokensMatch = part.match(/(\d+)\[(.+)\]/);
    if (tokensMatch) {
      var _ref2;

      var _tokensMatch = _slicedToArray(tokensMatch, 3),
          _ = _tokensMatch[0],
          line = _tokensMatch[1],
          tokens = _tokensMatch[2];

      var tokenList = tokens.split(",").map(expandString);
      return _defineProperty({}, line, (_ref2 = []).concat.apply(_ref2, _toConsumableArray(tokenList)));
    }

    var _part$split3 = part.split(":"),
        _part$split4 = _slicedToArray(_part$split3, 2),
        start = _part$split4[0],
        end = _part$split4[1];

    return mapRange([+start, +end || +start]);
  });

  return Object.assign.apply(Object, [{}].concat(_toConsumableArray(parts)));
};

var mapStep = exports.mapStep = function mapStep(step) {
  if (typeof step === "string") {
    return getTokensPerLineFromString(step);
  } else if (Object.keys(step).length === 0) {
    return { all: true };
  } else {
    return getTokensPerLineFromObject(step);
  }
};

var SelectedTokens = function () {
  function SelectedTokens(step) {
    _classCallCheck(this, SelectedTokens);

    this.tokensPerLine = mapStep(step);
  }

  _createClass(SelectedTokens, [{
    key: "isTokenSelected",
    value: function isTokenSelected(lineIndex, tokenIndex) {
      if (this.tokensPerLine.all) {
        return true;
      }
      return this.tokensPerLine[lineIndex + 1] !== undefined && (this.tokensPerLine[lineIndex + 1] === null || this.tokensPerLine[lineIndex + 1].includes(tokenIndex));
    }
  }, {
    key: "isLineSelected",
    value: function isLineSelected(lineIndex) {
      if (this.tokensPerLine.all) {
        return true;
      }
      return this.tokensPerLine[lineIndex + 1] !== undefined;
    }
  }]);

  return SelectedTokens;
}();

exports.default = SelectedTokens;